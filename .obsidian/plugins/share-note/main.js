/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// manifest.json
var require_manifest = __commonJS({
  "manifest.json"(exports, module2) {
    module2.exports = {
      id: "share-note",
      name: "Share Note",
      version: "0.5.22",
      minAppVersion: "0.15.0",
      description: "Instantly share a note, with the full theme and content exactly like you see in Reading View. Data is shared encrypted by default, and only you and the person you send it to have the key.",
      author: "Alan Grainger",
      authorUrl: "https://github.com/alangrainger",
      fundingUrl: "https://ko-fi.com/alan_",
      isDesktopOnly: false
    };
  }
});

// node_modules/data-uri-to-buffer/dist/index.js
var require_dist = __commonJS({
  "node_modules/data-uri-to-buffer/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.dataUriToBuffer = void 0;
    function base64ToArrayBuffer2(base64) {
      const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      const bytes = [];
      for (let i = 0; i < base64.length; i += 4) {
        const idx0 = chars.indexOf(base64.charAt(i));
        const idx1 = chars.indexOf(base64.charAt(i + 1));
        const idx2 = base64.charAt(i + 2) === "=" ? 0 : chars.indexOf(base64.charAt(i + 2));
        const idx3 = base64.charAt(i + 3) === "=" ? 0 : chars.indexOf(base64.charAt(i + 3));
        const bin0 = idx0 << 2 | idx1 >> 4;
        const bin1 = (idx1 & 15) << 4 | idx2 >> 2;
        const bin2 = (idx2 & 3) << 6 | idx3;
        bytes.push(bin0);
        if (base64.charAt(i + 2) !== "=")
          bytes.push(bin1);
        if (base64.charAt(i + 3) !== "=")
          bytes.push(bin2);
      }
      const buffer = new ArrayBuffer(bytes.length);
      const view = new Uint8Array(buffer);
      view.set(bytes);
      return buffer;
    }
    function stringToBuffer(str) {
      const buffer = new ArrayBuffer(str.length);
      const view = new Uint8Array(buffer);
      for (let i = 0; i < str.length; i++) {
        view[i] = str.charCodeAt(i);
      }
      return buffer;
    }
    function dataUriToBuffer2(uri) {
      uri = String(uri);
      if (!/^data:/i.test(uri)) {
        throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
      }
      uri = uri.replace(/\r?\n/g, "");
      const firstComma = uri.indexOf(",");
      if (firstComma === -1 || firstComma <= 4) {
        throw new TypeError("malformed data: URI");
      }
      const meta = uri.substring(5, firstComma).split(";");
      let charset = "";
      let base64 = false;
      const type = meta[0] || "text/plain";
      let typeFull = type;
      for (let i = 1; i < meta.length; i++) {
        if (meta[i] === "base64") {
          base64 = true;
        } else if (meta[i]) {
          typeFull += `;${meta[i]}`;
          if (meta[i].indexOf("charset=") === 0) {
            charset = meta[i].substring(8);
          }
        }
      }
      if (!meta[0] && !charset.length) {
        typeFull += ";charset=US-ASCII";
        charset = "US-ASCII";
      }
      const data = unescape(uri.substring(firstComma + 1));
      const buffer = base64 ? base64ToArrayBuffer2(data) : stringToBuffer(data);
      return {
        type,
        typeFull,
        charset,
        buffer
      };
    }
    exports.dataUriToBuffer = dataUriToBuffer2;
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => SharePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");

// src/settings.ts
var import_obsidian = require("obsidian");
var ThemeMode = /* @__PURE__ */ ((ThemeMode2) => {
  ThemeMode2[ThemeMode2["Same as theme"] = 0] = "Same as theme";
  ThemeMode2[ThemeMode2["Dark"] = 1] = "Dark";
  ThemeMode2[ThemeMode2["Light"] = 2] = "Light";
  return ThemeMode2;
})(ThemeMode || {});
var TitleSource = /* @__PURE__ */ ((TitleSource2) => {
  TitleSource2[TitleSource2["Note title"] = 0] = "Note title";
  TitleSource2[TitleSource2["First H1"] = 1] = "First H1";
  TitleSource2[TitleSource2["Frontmatter property"] = 2] = "Frontmatter property";
  return TitleSource2;
})(TitleSource || {});
var YamlField = /* @__PURE__ */ ((YamlField2) => {
  YamlField2[YamlField2["link"] = 0] = "link";
  YamlField2[YamlField2["updated"] = 1] = "updated";
  YamlField2[YamlField2["encrypted"] = 2] = "encrypted";
  YamlField2[YamlField2["unencrypted"] = 3] = "unencrypted";
  YamlField2[YamlField2["title"] = 4] = "title";
  return YamlField2;
})(YamlField || {});
var DEFAULT_SETTINGS = {
  server: "https://api.note.sx",
  uid: "",
  apiKey: "",
  yamlField: "share",
  noteWidth: "",
  theme: "",
  themeMode: 0 /* Same as theme */,
  titleSource: 0 /* Note title */,
  removeYaml: true,
  clipboard: true,
  shareUnencrypted: false,
  authRedirect: null
};
var ShareSettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("API key").setDesc("Click the button to request a new API key").addButton((btn) => btn.setButtonText("Connect plugin").setCta().onClick(() => {
      window.open(this.plugin.settings.server + "/v1/account/get-key?id=" + this.plugin.settings.uid);
    })).addText((inputEl) => {
      this.apikeyEl = inputEl;
      inputEl.setPlaceholder("API key").setValue(this.plugin.settings.apiKey).onChange(async (value) => {
        this.plugin.settings.apiKey = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Frontmatter property prefix").setDesc("The frontmatter property for storing the shared link and updated time. A value of `share` will create frontmatter fields of `share_link` and `share_updated`.").addText((text) => text.setPlaceholder(DEFAULT_SETTINGS.yamlField).setValue(this.plugin.settings.yamlField).onChange(async (value) => {
      this.plugin.settings.yamlField = value || DEFAULT_SETTINGS.yamlField;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Upload options").setHeading();
    new import_obsidian.Setting(containerEl).setName("Theme").setDesc("This is the theme used for your shared notes. To set a new theme, change the theme in Obsidian to your desired theme, then use the `Force re-upload all data` command. You can change your Obsidian theme after that without affecting the theme for your shared notes.").addText((text) => text.setValue(this.plugin.settings.theme || "Default theme").setDisabled(true));
    new import_obsidian.Setting(containerEl).setName("Light/Dark mode").setDesc("Choose the mode with which your files will be shared").addDropdown((dropdown) => {
      dropdown.addOption("Same as theme", "Same as theme").addOption("Dark", "Dark").addOption("Light", "Light").setValue(ThemeMode[this.plugin.settings.themeMode]).onChange(async (value) => {
        this.plugin.settings.themeMode = ThemeMode[value];
        await this.plugin.saveSettings();
      });
    });
    const defaultTitleDesc = "Select the location to source the published note title. It will default to the note title if nothing is found for the selected option.";
    const titleSetting = new import_obsidian.Setting(containerEl).setName("Note title source").setDesc(defaultTitleDesc).addDropdown((dropdown) => {
      for (const enumKey in TitleSource) {
        if (isNaN(Number(enumKey))) {
          dropdown.addOption(enumKey, enumKey);
        }
      }
      dropdown.setValue(TitleSource[this.plugin.settings.titleSource]).onChange(async (value) => {
        this.plugin.settings.titleSource = TitleSource[value];
        if (this.plugin.settings.titleSource === 2 /* Frontmatter property */) {
          titleSetting.setDesc("Set the title you want to use in a frontmatter property called `" + this.plugin.field(4 /* title */) + "`");
        } else {
          titleSetting.setDesc(defaultTitleDesc);
        }
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Note reading width").setDesc("The max width for the content of your shared note, accepts any CSS unit. Leave this value empty if you want to use the theme's width.").addText((text) => text.setValue(this.plugin.settings.noteWidth).onChange(async (value) => {
      this.plugin.settings.noteWidth = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Remove published frontmatter/YAML").setDesc("Remove frontmatter/YAML/properties from the shared note").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.removeYaml).onChange(async (value) => {
        this.plugin.settings.removeYaml = value;
        await this.plugin.saveSettings();
        this.display();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Copy the link to clipboard after sharing").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.clipboard).onChange(async (value) => {
        this.plugin.settings.clipboard = value;
        await this.plugin.saveSettings();
        this.display();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Share as encrypted by default").setDesc("If you turn this off, you can enable encryption for individual notes by adding a `share_encrypted` checkbox into a note and ticking it.").addToggle((toggle) => {
      toggle.setValue(!this.plugin.settings.shareUnencrypted).onChange(async (value) => {
        this.plugin.settings.shareUnencrypted = !value;
        await this.plugin.saveSettings();
        this.display();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Debug info").setHeading();
    new import_obsidian.Setting(containerEl).setName("User ID").setDesc("If you need it for debugging purposes, this is your user ID").addText((text) => text.setValue(this.plugin.settings.uid).setDisabled(true));
  }
};

// src/note.ts
var import_obsidian3 = require("obsidian");

// src/crypto.ts
async function _generateKey(seed) {
  const keyMaterial = await window.crypto.subtle.importKey(
    "raw",
    seed,
    { name: "PBKDF2" },
    false,
    ["deriveBits"]
  );
  const masterKey = await window.crypto.subtle.deriveBits(
    {
      name: "PBKDF2",
      salt: new Uint8Array(16),
      iterations: 1e5,
      hash: "SHA-256"
    },
    keyMaterial,
    256
  );
  return new Uint8Array(masterKey);
}
function masterKeyToString(masterKey) {
  return arrayBufferToBase64(masterKey);
}
function arrayBufferToBase64(buffer) {
  let binary = "";
  const bytes = new Uint8Array(buffer);
  for (let i = 0; i < bytes.byteLength; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return window.btoa(binary);
}
function base64ToArrayBuffer(base64) {
  return Uint8Array.from(window.atob(base64), (c) => c.charCodeAt(0));
}
function _getAesGcmKey(secret) {
  return window.crypto.subtle.importKey(
    "raw",
    secret,
    { name: "AES-GCM", length: 256 },
    false,
    ["encrypt", "decrypt"]
  );
}
async function encryptString(plaintext, existingKey) {
  let key;
  if (existingKey) {
    key = base64ToArrayBuffer(existingKey);
  } else {
    key = await _generateKey(window.crypto.getRandomValues(new Uint8Array(64)));
  }
  const iv = window.crypto.getRandomValues(new Uint8Array(16));
  const aesKey = await _getAesGcmKey(key);
  const ciphertext = [];
  const length = plaintext.length;
  const chunkSize = 1e3;
  let index = 0;
  while (index * chunkSize < length) {
    const plaintextChunk = plaintext.slice(index * chunkSize, (index + 1) * chunkSize);
    const encodedText = new TextEncoder().encode(plaintextChunk);
    const bufCiphertext = await window.crypto.subtle.encrypt(
      { name: "AES-GCM", iv },
      aesKey,
      encodedText
    );
    ciphertext.push(arrayBufferToBase64(bufCiphertext));
    index++;
  }
  return {
    ciphertext,
    iv: arrayBufferToBase64(iv),
    key: masterKeyToString(key).slice(0, 43)
  };
}
async function sha(algorithm, data) {
  let uint8Array;
  if (typeof data === "string") {
    const encoder = new TextEncoder();
    uint8Array = encoder.encode(data);
  } else {
    uint8Array = data;
  }
  const hash = await crypto.subtle.digest(algorithm, uint8Array);
  return Array.from(new Uint8Array(hash)).map((b) => b.toString(16).padStart(2, "0")).join("");
}
async function sha256(data) {
  return sha("SHA-256", data);
}
async function sha1(data) {
  return sha("SHA-1", data);
}
async function shortHash(text) {
  return (await sha256(text)).slice(0, 32);
}

// src/StatusMessage.ts
var import_obsidian2 = require("obsidian");
var pluginName = require_manifest().name;
var statuses = {
  [2 /* Error */]: {
    class: "share-note-status-error",
    icon: "\u274C "
  },
  [1 /* Info */]: {
    class: "share-note-status-info",
    icon: ""
  },
  [3 /* Success */]: {
    class: "share-note-status-success",
    icon: "\u2714 "
  }
};
var StatusMessage = class extends import_obsidian2.Notice {
  constructor(text, type = 0 /* Default */, duration = 5e3) {
    var _a;
    const messageDoc = new DocumentFragment();
    const icon = ((_a = statuses[type]) == null ? void 0 : _a.icon) || "";
    const messageEl = messageDoc.createEl("div", {
      text: `${icon}${pluginName}: ${text}`
    });
    super(messageDoc, duration);
    if (messageEl.parentElement) {
      if (statuses[type]) {
        messageEl.parentElement.classList.add(statuses[type].class);
      }
    }
    this.icon = icon;
    this.messageEl = messageEl;
  }
  setStatus(message) {
    this.messageEl.innerText = `${this.icon}${pluginName}: ${message}`;
  }
};

// src/NoteTemplate.ts
function getElementStyle(key, element) {
  const elementStyle = {
    element: key,
    classes: [],
    style: ""
  };
  try {
    elementStyle.classes = Array.from(element.classList);
    const style = element.style;
    if (element.classList.contains("markdown-preview-pusher")) {
      style.removeProperty("margin-bottom");
    }
    elementStyle.style = style.cssText;
  } catch (e) {
    console.log(e);
  }
  return elementStyle;
}
var NoteTemplate = class {
  constructor() {
    this.elements = [];
  }
};

// src/note.ts
var import_data_uri_to_buffer = __toESM(require_dist());

// src/libraries/FileTypes.ts
var FileType = class {
  constructor(fileType) {
    this.extension = fileType.extension;
    this.mimetypes = fileType.mimetypes;
    this.signature = fileType.signature;
  }
  get mimetype() {
    return this.mimetypes[0];
  }
};
var types = [
  {
    extension: "ttf",
    mimetypes: ["font/ttf", "application/x-font-ttf", "application/x-font-truetype", "font/truetype"],
    signature: new Uint8Array([0, 1, 0, 0, 0])
  },
  {
    extension: "otf",
    mimetypes: ["font/otf", "application/x-font-opentype"],
    signature: new Uint8Array([79, 84, 84, 79])
  },
  {
    extension: "woff",
    mimetypes: ["font/woff", "application/font-woff", "application/x-font-woff"],
    signature: new Uint8Array([119, 79, 70, 70])
  },
  {
    extension: "woff2",
    mimetypes: ["font/woff2", "application/font-woff2", "application/x-font-woff2"],
    signature: new Uint8Array([119, 79, 70, 50])
  },
  {
    extension: "svg",
    mimetypes: ["image/svg+xml"]
  }
];
var FileTypes = class {
  getFromMimetype(mimetype) {
    const type = types.find((x) => x.mimetypes.includes(mimetype));
    return type ? new FileType(type) : void 0;
  }
  getFromExtension(extension) {
    const type = types.find((x) => x.extension === extension.toLowerCase());
    return type ? new FileType(type) : void 0;
  }
  getFromSignature(signature) {
    if (signature instanceof ArrayBuffer) {
      signature = new Uint8Array(signature, 0, 10);
    }
    const type = types.find((library) => library.signature && this.bufferIsEqual(library.signature, signature));
    return type ? new FileType(type) : void 0;
  }
  bufferIsEqual(librarySignature, userSignature) {
    for (let i = 0; i < librarySignature.length; i++) {
      if (librarySignature[i] !== (userSignature == null ? void 0 : userSignature[i])) {
        return false;
      }
    }
    return true;
  }
};
var FileTypes_default = new FileTypes();

// src/note.ts
var cssAttachmentWhitelist = {
  ttf: ["font/ttf", "application/x-font-ttf", "application/x-font-truetype", "font/truetype"],
  otf: ["font/otf", "application/x-font-opentype"],
  woff: ["font/woff", "application/font-woff", "application/x-font-woff"],
  woff2: ["font/woff2", "application/font-woff2", "application/x-font-woff2"],
  svg: ["image/svg+xml"]
};
var Note = class {
  constructor(plugin) {
    this.isEncrypted = true;
    this.isForceUpload = false;
    this.isForceClipboard = false;
    this.isUploadCss = false;
    this.plugin = plugin;
    this.leaf = this.plugin.app.workspace.getLeaf();
    this.template = new NoteTemplate();
    this.elements = [];
  }
  /**
   * Return the name (key) of a frontmatter property, eg 'share_link'
   * @param key
   * @return {string} The name (key) of a frontmatter property
   */
  field(key) {
    return this.plugin.field(key);
  }
  async share() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
    this.status = new StatusMessage("Sharing note...", 0 /* Default */, 60 * 1e3);
    if (!this.plugin.settings.apiKey) {
      this.plugin.authRedirect("share").then();
      window.open(this.plugin.settings.server + "/v1/account/get-key?id=" + this.plugin.settings.uid);
      return;
    }
    this.uploadedFiles = [];
    const startMode = this.leaf.getViewState();
    const previewMode = this.leaf.getViewState();
    previewMode.state.mode = "preview";
    await this.leaf.setViewState(previewMode);
    await new Promise((resolve) => setTimeout(resolve, 200));
    this.leaf.view.previewMode.applyScroll(0);
    await new Promise((resolve) => setTimeout(resolve, 500));
    try {
      this.elements.push(getElementStyle("body", document.body));
      const previewEl = this.leaf.view.containerEl.querySelector(".markdown-preview-view.markdown-rendered");
      if (previewEl)
        this.elements.push(getElementStyle("preview", previewEl));
      const pusherEl = this.leaf.view.containerEl.querySelector(".markdown-preview-pusher");
      if (pusherEl)
        this.elements.push(getElementStyle("pusher", pusherEl));
      const noteHtml = this.leaf.view.modes.preview.renderer.sections.reduce((p, c) => p + c.el.outerHTML, "");
      this.contentDom = new DOMParser().parseFromString(noteHtml, "text/html");
      this.cssRules = [];
      Array.from(document.styleSheets).forEach((x) => Array.from(x.cssRules).forEach((rule) => {
        this.cssRules.push(rule);
      }));
      this.css = this.cssRules.map((rule) => rule.cssText).join("").replace(/\n/g, "");
    } catch (e) {
      console.log(e);
      this.status.hide();
      new StatusMessage("Failed to parse current note, check console for details", 2 /* Error */);
      return;
    }
    setTimeout(() => {
      this.leaf.setViewState(startMode);
    }, 400);
    const file = this.plugin.app.workspace.getActiveFile();
    if (!(file instanceof import_obsidian3.TFile)) {
      this.status.hide();
      new StatusMessage("There is no active file to share");
      return;
    }
    this.meta = this.plugin.app.metadataCache.getFileCache(file);
    if (this.plugin.settings.removeYaml) {
      (_a = this.contentDom.querySelector("div.metadata-container")) == null ? void 0 : _a.remove();
      (_b = this.contentDom.querySelector("pre.frontmatter")) == null ? void 0 : _b.remove();
      (_c = this.contentDom.querySelector("div.frontmatter-container")) == null ? void 0 : _c.remove();
    }
    const defaultCalloutType = this.getCalloutIcon((selectorText) => selectorText === ".callout") || "pencil";
    for (const el of this.contentDom.getElementsByClassName("callout")) {
      const type = el.getAttribute("data-callout");
      let icon = this.getCalloutIcon((selectorText) => selectorText.includes(`data-callout="${type}"`)) || defaultCalloutType;
      icon = icon.replace("lucide-", "");
      const iconEl = el.querySelector("div.callout-icon");
      const svgEl = iconEl == null ? void 0 : iconEl.querySelector("svg");
      if (svgEl) {
        svgEl.outerHTML = `<svg width="16" height="16" data-share-note-lucide="${icon}"></svg>`;
      }
    }
    for (const el of this.contentDom.querySelectorAll("a.internal-link")) {
      const href = el.getAttribute("href");
      const match = href ? href.match(/^([^#]+)/) : null;
      if (href == null ? void 0 : href.match(/^#/)) {
        const selector = `[data-heading="${href.slice(1)}"]`;
        if ((_d = this.contentDom.querySelectorAll(selector)) == null ? void 0 : _d[0]) {
          el.setAttribute("onclick", `document.querySelectorAll('${selector}')[0].scrollIntoView(true)`);
        }
        el.removeAttribute("target");
        el.removeAttribute("href");
        continue;
      } else if (match) {
        const linkedFile = this.plugin.app.metadataCache.getFirstLinkpathDest(match[1], "");
        if (linkedFile instanceof import_obsidian3.TFile) {
          const linkedMeta = this.plugin.app.metadataCache.getFileCache(linkedFile);
          if ((_e = linkedMeta == null ? void 0 : linkedMeta.frontmatter) == null ? void 0 : _e[this.field(0 /* link */)]) {
            el.setAttribute("href", linkedMeta.frontmatter[this.field(0 /* link */)]);
            el.removeAttribute("target");
            continue;
          }
        }
      }
      el.replaceWith(el.innerHTML);
    }
    for (const el of this.contentDom.querySelectorAll("a.external-link")) {
      el.removeAttribute("target");
    }
    const uploadResult = await this.processMedia();
    if (!((_f = uploadResult == null ? void 0 : uploadResult.css) == null ? void 0 : _f.url)) {
      this.isUploadCss = true;
    }
    await this.processCss();
    this.status.setStatus("Processing note...");
    let decryptionKey = "";
    if ((_h = (_g = this.meta) == null ? void 0 : _g.frontmatter) == null ? void 0 : _h[this.field(0 /* link */)]) {
      const match = this.meta.frontmatter[this.field(0 /* link */)].match(/https:\/\/[^/]+(?:\/\w{2}|)\/(\w+).*?(#.+?|)$/);
      if (match) {
        this.template.filename = match[1];
        decryptionKey = match[2].slice(1);
      }
    }
    this.template.encrypted = this.isEncrypted;
    let title;
    switch (this.plugin.settings.titleSource) {
      case 1 /* First H1 */:
        title = (_j = (_i = this.contentDom.getElementsByTagName("h1")) == null ? void 0 : _i[0]) == null ? void 0 : _j.innerText;
        break;
      case 2 /* Frontmatter property */:
        title = (_l = (_k = this.meta) == null ? void 0 : _k.frontmatter) == null ? void 0 : _l[this.field(4 /* title */)];
        break;
    }
    if (!title) {
      title = file.basename;
    }
    if (this.isEncrypted) {
      this.status.setStatus("Encrypting note...");
      const plaintext = JSON.stringify({
        content: this.contentDom.body.innerHTML,
        basename: title
      });
      const encryptedData = await encryptString(plaintext, decryptionKey);
      this.template.content = JSON.stringify({
        ciphertext: encryptedData.ciphertext,
        iv: encryptedData.iv
      });
      decryptionKey = encryptedData.key;
    } else {
      this.template.content = this.contentDom.body.innerHTML;
      this.template.title = title;
      const desc = Array.from(this.contentDom.querySelectorAll("p")).map((x) => x.innerText).filter((x) => !!x).join(" ");
      this.template.description = desc.length > 200 ? desc.slice(0, 197) + "..." : desc;
    }
    this.template.width = this.plugin.settings.noteWidth;
    if (this.plugin.settings.themeMode !== 0 /* Same as theme */) {
      this.elements.filter((x) => x.element === "body").forEach((item) => {
        item.classes = item.classes.filter((cls) => cls !== "theme-dark" && cls !== "theme-light");
        item.classes.push("theme-" + ThemeMode[this.plugin.settings.themeMode].toLowerCase());
      });
    }
    this.template.elements = this.elements;
    this.template.mathJax = !!this.contentDom.body.innerHTML.match(/<mjx-container/);
    this.status.setStatus("Uploading note...");
    let shareLink = await this.plugin.api.createNote(this.template);
    (0, import_obsidian3.requestUrl)(shareLink).then().catch();
    if (shareLink && this.isEncrypted) {
      shareLink += "#" + decryptionKey;
    }
    let shareMessage = "The note has been shared";
    if (shareLink) {
      await this.plugin.app.fileManager.processFrontMatter(file, (frontmatter) => {
        frontmatter[this.field(0 /* link */)] = shareLink;
        frontmatter[this.field(1 /* updated */)] = (0, import_obsidian3.moment)().format();
      });
      if (this.plugin.settings.clipboard || this.isForceClipboard) {
        try {
          await navigator.clipboard.writeText(shareLink);
          shareMessage = `${shareMessage} and the link is copied to your clipboard \u{1F4CB}`;
        } catch (e) {
        }
        this.isForceClipboard = false;
      }
    }
    this.status.hide();
    new StatusMessage(shareMessage, 3 /* Success */);
  }
  /**
   * Upload media attachments
   */
  async processMedia() {
    const elements = ["img", "video"];
    this.status.setStatus("Processing attachments...");
    for (const el of this.contentDom.querySelectorAll(elements.join(","))) {
      const src = el.getAttribute("src");
      if (!src || !src.startsWith("app://"))
        continue;
      const srcMatch = src.match(/app:\/\/\w+\/([^?#]+)/);
      if (!srcMatch)
        continue;
      const localFile = window.decodeURIComponent(srcMatch[1]);
      const content = await import_obsidian3.FileSystemAdapter.readLocalFile(localFile);
      const hash = await sha1(content);
      const filetype = localFile.split(".").pop();
      if (filetype) {
        this.plugin.api.queueUpload({
          data: {
            filetype,
            hash,
            content,
            byteLength: content.byteLength
          },
          callback: (url) => el.setAttribute("src", url)
        });
      }
      el.removeAttribute("alt");
    }
    return this.plugin.api.processQueue(this.status);
  }
  /**
   * Upload theme CSS, unless this file has previously been shared,
   * or the user has requested a force re-upload
   */
  async processCss() {
    var _a, _b;
    if (this.isForceUpload || this.isUploadCss) {
      this.status.setStatus("Processing CSS...");
      const attachments = this.css.match(/url\s*\(.*?\)/g) || [];
      for (const attachment of attachments) {
        const assetMatch = attachment.match(/url\s*\(\s*"*(.*?)\s*(?<!\\)"\s*\)/);
        if (!assetMatch)
          continue;
        const assetUrl = (assetMatch == null ? void 0 : assetMatch[1]) || "";
        if (assetUrl.startsWith("data:")) {
          const parsed = (0, import_data_uri_to_buffer.dataUriToBuffer)(assetUrl);
          if (parsed == null ? void 0 : parsed.type) {
            if (parsed.type === "application/octet-stream") {
              const decoded = FileTypes_default.getFromSignature(parsed.buffer);
              if (!decoded)
                continue;
              parsed.type = decoded.mimetype;
            }
            const filetype = this.extensionFromMime(parsed.type);
            if (filetype) {
              const hash = await sha1(parsed.buffer);
              this.plugin.api.queueUpload({
                data: {
                  filetype,
                  hash,
                  content: parsed.buffer,
                  byteLength: parsed.buffer.byteLength
                },
                callback: (url) => {
                  this.css = this.css.replace(assetMatch[0], `url("${url}")`);
                }
              });
            }
          }
        } else if (assetUrl && !assetUrl.startsWith("http")) {
          const filename = assetUrl.match(/([^/\\]+)\.(\w+)$/);
          if (filename) {
            if (cssAttachmentWhitelist[filename[2]]) {
              const res = await fetch(assetUrl);
              const contents = await res.arrayBuffer();
              const hash = await sha1(contents);
              this.plugin.api.queueUpload({
                data: {
                  filetype: filename[2],
                  hash,
                  content: contents,
                  byteLength: contents.byteLength
                },
                callback: (url) => {
                  this.css = this.css.replace(assetMatch[0], `url("${url}")`);
                }
              });
            }
          }
        }
      }
      this.status.setStatus("Uploading CSS attachments...");
      await this.plugin.api.processQueue(this.status, "CSS attachment");
      this.status.setStatus("Uploading CSS...");
      const cssHash = await sha1(this.css);
      try {
        await this.plugin.api.upload({
          filetype: "css",
          hash: cssHash,
          content: this.css,
          byteLength: this.css.length
        });
        this.plugin.settings.theme = ((_b = (_a = this.plugin.app) == null ? void 0 : _a.customCss) == null ? void 0 : _b.theme) || "";
        await this.plugin.saveSettings();
      } catch (e) {
      }
    }
  }
  getCalloutIcon(test) {
    const rule = this.cssRules.find((rule2) => rule2.selectorText && test(rule2.selectorText) && rule2.style.getPropertyValue("--callout-icon"));
    if (rule) {
      return rule.style.getPropertyValue("--callout-icon");
    }
    return "";
  }
  /**
   * Turn the font mime-type into an extension.
   * @param {string} mimeType
   * @return {string|undefined}
   */
  extensionFromMime(mimeType) {
    const mimes = cssAttachmentWhitelist;
    return Object.keys(mimes).find((x) => mimes[x].includes((mimeType || "").toLowerCase()));
  }
  /**
   * Force all related assets to upload again
   */
  forceUpload() {
    this.isForceUpload = true;
  }
  /**
   * Copy the shared link to the clipboard, regardless of the user setting
   */
  forceClipboard() {
    this.isForceClipboard = true;
  }
  /**
   * Enable/disable encryption for the note
   */
  shareAsPlainText(isPlainText) {
    this.isEncrypted = !isPlainText;
  }
};

// src/api.ts
var import_obsidian4 = require("obsidian");
var pluginVersion = require_manifest().version;
var API = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.uploadQueue = [];
  }
  async authHeaders() {
    const nonce = Date.now().toString();
    return {
      "x-sharenote-id": this.plugin.settings.uid,
      "x-sharenote-key": await sha256(nonce + this.plugin.settings.apiKey),
      "x-sharenote-nonce": nonce,
      "x-sharenote-version": pluginVersion
    };
  }
  async post(endpoint, data, retries = 1) {
    var _a;
    const headers = {
      ...await this.authHeaders(),
      "Content-Type": "application/json"
    };
    if (data == null ? void 0 : data.byteLength)
      headers["x-sharenote-bytelength"] = data.byteLength.toString();
    const body = Object.assign({}, data);
    while (retries > 0) {
      try {
        const res = await (0, import_obsidian4.requestUrl)({
          url: this.plugin.settings.server + endpoint,
          method: "POST",
          headers,
          body: JSON.stringify(body)
        });
        return res.json;
      } catch (error) {
        if (error.status < 500 || retries <= 1) {
          const message = (_a = error.headers) == null ? void 0 : _a.message;
          if (message) {
            new StatusMessage(message, 2 /* Error */);
            throw new Error("Known error");
          }
          throw new Error("Unknown error");
        } else {
          await new Promise((resolve) => setTimeout(resolve, 1e3));
        }
      }
      console.log("Retrying " + retries);
      retries--;
    }
  }
  async postRaw(endpoint, data, retries = 4) {
    const headers = {
      ...await this.authHeaders(),
      "x-sharenote-filetype": data.filetype,
      "x-sharenote-hash": data.hash
    };
    if (data.byteLength)
      headers["x-sharenote-bytelength"] = data.byteLength.toString();
    while (retries > 0) {
      const res = await fetch(this.plugin.settings.server + endpoint, {
        method: "POST",
        headers,
        body: data.content
      });
      if (res.status !== 200) {
        if (res.status < 500 || retries <= 1) {
          const message = await res.text();
          if (message) {
            new StatusMessage(message, 2 /* Error */);
            throw new Error("Known error");
          }
          throw new Error("Unknown error");
        }
        await new Promise((resolve) => setTimeout(resolve, 1e3));
      } else {
        return res.json();
      }
      console.log("Retrying " + retries);
      retries--;
    }
  }
  queueUpload(item) {
    this.uploadQueue.push(item);
  }
  async processQueue(status, type = "attachment") {
    const res = await this.post("/v1/file/check-files", {
      files: this.uploadQueue.map((x) => {
        return {
          hash: x.data.hash,
          filetype: x.data.filetype,
          byteLength: x.data.byteLength
        };
      })
    });
    let count = 1;
    const promises = [];
    for (const queueItem of this.uploadQueue) {
      const checkFile = res == null ? void 0 : res.files.find((item) => item.hash === queueItem.data.hash && item.filetype === queueItem.data.filetype);
      if (checkFile == null ? void 0 : checkFile.url) {
        status.setStatus(`Uploading ${type} ${count++} of ${this.uploadQueue.length}...`);
        queueItem.callback(checkFile.url);
      } else {
        promises.push(new Promise((resolve) => {
          this.postRaw("/v1/file/upload", queueItem.data).then((res2) => {
            status.setStatus(`Uploading ${type} ${count++} of ${this.uploadQueue.length}...`);
            queueItem.callback(res2.url);
            resolve();
          }).catch((e) => {
            console.log(e);
            resolve();
          });
        }));
      }
    }
    await Promise.all(promises);
    this.uploadQueue = [];
    return res;
  }
  async upload(data) {
    return this._upload(data);
  }
  async _upload(data) {
    const exists = await this.post("/v1/file/check-file", {
      filetype: data.filetype,
      hash: data.hash,
      byteLength: data.byteLength
    });
    if (exists == null ? void 0 : exists.success) {
      return exists.url;
    } else {
      const res = await this.postRaw("/v1/file/upload", data);
      return res.url;
    }
  }
  async createNote(template) {
    const res = await this.post("/v1/file/create-note", {
      filename: template.filename,
      filetype: "html",
      hash: await sha1(template.content),
      template
    }, 3);
    return res.url;
  }
};

// src/main.ts
var SharePlugin = class extends import_obsidian5.Plugin {
  constructor() {
    super(...arguments);
    // Expose some tools in the plugin object
    this.hash = shortHash;
    this.sha256 = sha256;
  }
  async onload() {
    await this.loadSettings();
    if (!this.settings.uid) {
      this.settings.uid = await shortHash("" + Date.now() + Math.random());
      await this.saveSettings();
    }
    if (this.settings.server === "https://api.obsidianshare.com") {
      this.settings.server = "https://api.note.sx";
      await this.saveSettings();
    }
    this.settingsPage = new ShareSettingsTab(this.app, this);
    this.addSettingTab(this.settingsPage);
    this.api = new API(this);
    this.registerObsidianProtocolHandler("share-note", async (data) => {
      if (data.action === "share-note" && data.key) {
        this.settings.apiKey = data.key;
        await this.saveSettings();
        if (this.settingsPage.apikeyEl) {
          this.settingsPage.apikeyEl.setValue(data.key);
        }
        if (this.settings.authRedirect === "share") {
          this.authRedirect(null).then();
          this.uploadNote().then();
        } else {
          new StatusMessage("Plugin successfully connected. You can now start sharing notes!", 3 /* Success */, 6e3);
        }
      }
    });
    this.addCommand({
      id: "share-note",
      name: "Share current note",
      callback: () => this.uploadNote()
    });
    this.addCommand({
      id: "force-upload",
      name: "Force re-upload of all data for this note",
      callback: () => this.uploadNote(true)
    });
    this.addCommand({
      id: "copy-link",
      name: "Copy shared note link",
      checkCallback: (checking) => {
        const file = this.app.workspace.getActiveFile();
        if (checking) {
          return file instanceof import_obsidian5.TFile;
        } else if (file) {
          this.copyShareLink(file);
        }
      }
    });
    this.registerEvent(
      this.app.workspace.on("file-menu", (menu, file) => {
        if (file instanceof import_obsidian5.TFile && file.extension === "md") {
          menu.addItem((item) => {
            item.setIcon("share-2");
            item.setTitle("Copy shared link");
            item.onClick(async () => {
              await this.copyShareLink(file);
            });
          });
        }
      })
    );
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  /**
   * Upload a note.
   * @param forceUpload - Optionally force an upload of all related assets
   * @param forceClipboard - Optionally copy the link to the clipboard, regardless of the user setting
   */
  async uploadNote(forceUpload = false, forceClipboard = false) {
    var _a, _b;
    const file = this.app.workspace.getActiveFile();
    if (file instanceof import_obsidian5.TFile) {
      const meta = this.app.metadataCache.getFileCache(file);
      const note = new Note(this);
      if (this.settings.shareUnencrypted) {
        note.shareAsPlainText(true);
      }
      if (((_a = meta == null ? void 0 : meta.frontmatter) == null ? void 0 : _a[note.field(3 /* unencrypted */)]) === true) {
        note.shareAsPlainText(true);
      }
      if (((_b = meta == null ? void 0 : meta.frontmatter) == null ? void 0 : _b[note.field(2 /* encrypted */)]) === true) {
        note.shareAsPlainText(false);
      }
      if (forceUpload) {
        note.forceUpload();
      }
      if (forceClipboard) {
        note.forceClipboard();
      }
      try {
        await note.share();
      } catch (e) {
        if (e.message !== "Known error") {
          console.log(e);
          new StatusMessage("There was an error uploading the note, please try again.", 2 /* Error */);
        }
      }
      note.status.hide();
    }
  }
  /**
   * Copy the share link to the clipboard. The note will be shared first if neccessary.
   * @param file
   */
  async copyShareLink(file) {
    var _a;
    const meta = this.app.metadataCache.getFileCache(file);
    const shareLink = (_a = meta == null ? void 0 : meta.frontmatter) == null ? void 0 : _a[this.settings.yamlField + "_" + YamlField[0 /* link */]];
    if (shareLink) {
      await navigator.clipboard.writeText(shareLink);
      new StatusMessage("\u{1F4CB} Shared link copied to clipboard");
    } else {
      await this.uploadNote(false, true);
    }
    return shareLink;
  }
  /**
   * Redirect a user back to their position in the flow after they finish the auth.
   * NULL to clear the redirection.
   */
  async authRedirect(value) {
    this.settings.authRedirect = value;
    await this.saveSettings();
  }
  field(key) {
    return [this.settings.yamlField, YamlField[key]].join("_");
  }
};
